def encrypt(message,key):

    #LETTERS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ #'
    LETTERS = '''0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"$%&\'()*+,-./:;<=>?@[]^_`{|}~ #'''
    encrypted = list()

    """ Need to recycle key number """
    if key >= len(LETTERS) :
       key %= len(LETTERS)

    """ Conditions which can save time followed by main """
    if key < 0 :
       print("Invalid Key. Enter a positive integer.")
    elif key == 0 :
       print(message + " , " + "Decryption Key : " + str(key) )
    else :
       for letter in message :
           if LETTERS.find(letter) + key >= len(LETTERS):
               position = LETTERS.find(letter) +  key - len(LETTERS)
#              position = key
           else :
               position = LETTERS.find(letter) + key

           encrypted.append(LETTERS[position])
       print("Encrypted Text : " + "'" + ''.join(encrypted) + "'" + " , " + "Decryption Key : " + str(key) )



## CHECK FOR \ issue , Enter string (((( , and key 1 , then decrypt the output
DICT = '''0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"$%&'(\)*+,-./:;<=>?@[]^_`{|}~ #\n\t'''
DICT_LEN = len(DICT)
print(DICT_LEN)
print(DICT[0])
#print(DICT[0+95])
DICT_KEYS = dict()


class Encrypt():
    
    #def __init__(self):
    #    pass
        
    def get_text(self):
        self.text = str(input('Enter the text to be encrypted : '))
        return self.text
    
    
    def get_text_from_file(self):
        
        try:
            self.file = str(input('''Enter the file with path to be encrypted :  '''))
        except FileNotFoundError:
            print('File not found !')
        else:
            with open(self.file,'r') as f:
                f_contents = f.read()
                print(f_contents)
                return f_contents   
    
    def get_key(self):
        
        self.DICT_KEYS = dict()
        
        ### Input ###
        while True:
            try:
                self.en_key = int(input('Enter the key : '))
                if type(self.en_key) == type(float()):
                    raise ValueError
            except ValueError:
                print(f'Key can only be a positive or negative integer number!')
            else:
                break
        
        original_key = self.en_key
        ### TURN THE LETTERS ###
        if self.en_key == 0:       # Key is 0   
           
            self.DICT_KEYS = { letter:letter for letter in DICT }
        
        else:                      # Key is positive 
            
            self.en_key %= DICT_LEN   #If absolute value of key greater DICT_LEN it will reduce the key else will remain same 
            for index,letter in enumerate(DICT):

                new_index = (self.en_key  + index) % DICT_LEN   # since new_index will go over dict_len , cycle  
                self.DICT_KEYS[letter] = DICT[new_index]        # Creates dictionary map

        
        print(self.DICT_KEYS)
        return self.DICT_KEYS, original_key, self.en_key                   
    
    
    
    def encrypt_text(self, text, dict_keys, original_key, new_key):
        
        return ''.join([ dict_keys[letter] for letter in text ]), original_key, new_key

    
    
e = Encrypt() 
#text = e.get_text()

e.get_text_from_file()
#dict_keys, original_key, new_key = e.get_key()
#e.encrypt_text(text, dict_keys, original_key, new_key)
#e.encrypt_text(text, dict_keys, original_key, new_key)
